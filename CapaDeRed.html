<html>
<head>
  <title>CAPA DE RED</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <link rel="stylesheet" type="text/css" href="comu_style.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Ubuntu" />
  <img class="terry" src="terry.jpg"/>
</head>

<body>
<div class="ubuntu_letra border">
<pre>
<p class="blue grande">Problemas de diseño de la capa de red.</p>
· Conmutación de paquetes de almacenamiento y reenvío.
· Servicios ofrecidos a la capa de transporte.
· Implementación de servicios sin conexión.
· Implementacion dee servicios orientados a la conexión.
· Comparación entre las redes de circuitos virtuales y datagramas.

<p class="blue grande">Conmutación de paquetes de almacenamiento y reenvío.</p>
Un host que desea enviar un paquete lo transmite al enrutador más cercano, ya
sea en su propia LAN o a través de un enlace punto a punto que va al ISP. El
paquete se almacena ahí hasta que haya llegado por completo y el enlace haya
terminado su procesamiento mediante la comprobación de la suma de verificación
Después se reenvía al siguiente enrutador de la ruta hasta que llega al host
destino, en donde se entrega. Este mecanismo se denomina conmutación de 
almacenamiento y envío.


<p class="blue grande">Servicios proporcionados a la capa de transporte</p>
· Los servicios deben ser independientes de la tecnología del enrutador.
· La capa de transporte debe estar aislada de la cantidad, tipo y topología
de los enrutadores presentes.
· Las direcciones de red disponibles para la capa de transporte deben usar
 un plan de numeración iguales(uniforme), incluso a través de las redes LAN y WAN.

<p class="blue grande">Implementación del servicio sin conexión</p>
En este contexto, por lo general los paquetes se conocen como datagramas
(en analogía con los telegramas) y la red se conoce como red de datagramas.

<p class="green">Ver figura 5.2</p>
En A, los paquetes 1,2 y 3 se almancenan unos momentos, después de haber 
llegado por el enlace entrante y de haber comprobado sus sumas de verificación.
Después cada paquete se reenvía de acuerdo con la tabla de A, por el enlace
de salida a C dentro de una nueva trama. Después, el paquete 1 se reenvía a E
y después a F. Cuando llega a F, se envía dentro de una trama a H2 a  través 
de la LAN. Los paquetes 2 y 3 siguen la misma ruta.
Pero con el 4to paquete, cuando llega a A se envía al enrutador B, aun cuando
también está  destinado a F. Por alguna razón, A decidió enviar el paquete 4
por una ruta diferente a la de los primeros tres paquetes, ya sea por una 
congestión de tráfico en alguna parte de la ruta ACE y actualizó su tabla 
de enrutamiento. A este algoritmo se lo conoce como algoritmo de enrutamiento.

<p class="blue grande">Implementación del servicio orientado a la conexión</p>
En este contexto la conexión se conoce como VC (circuito virtual), en analogía
con los circuitos físicos establecidos por el sistema telefónico, y la red se
denomina red de circuitos virtuales.

<p class="green">Ver figura 5-3</p>
El host H1 ha establecido una conexión 1 con el host H2. Esta conexión se recuerda como
la primera entrada en cada una de las tablas de enrutamiento. La primera línea de la tabla
A indica que si un paquete con el identificador de conexión 1 viene de H1, se enviará al
enrutador C y se le dará el identificador de conexión 1. De manera similar, la primera
entrada en C enruta el paquete a E, también con el identificador de conexión 1.
Ahora si H3 también desea establecer una conexión con H2. Elige el identificador de conexión
1 (debido a que está iniciando la conexión y a que ésta es su única conexión) y le indica
a la red que establezca el circuito virtual. Ahora aunque A sí puede saber con facilidad
cuáles paquetes de conexión 1 provienen de H1 y cuáles proviene de H3, C no puede saberlo.
Por esta razón, A asigna un identificador de conexión diferente al tráfico de salida para
la sengunda conexión. Evitar confluctors de este tipo es la razón por la cual los enrutadores
necesitan la habilidad de reemplazar identificadores de conexión en los paquetes de salida.
A este proceso se lee conoce como CONMUTACIÓN MEDIANTE ETIQUETAS. 

<p class="blue grande">MPLS (Conmutación Multiprotocolo Mediante Etiquetas)</p>
Es un protocolo orientado a la conexión se utiliza dentro de las redes ISP en Internet, en
donde los paquetes IP se envuelven en un encabezado MPLS que tiene un identificador de 
conexión o etiqueta de 20 bits. El servicio MPLS se oculta de los clientes.

<p class="green">Ver Figura 5-4 (comparación entre red de datagramas y circuitos virtuales)</p>

<p class="blue grande">ALGORITMOS DE ENRUTAMIENTO</p>
· Principio de optimización.
· Algoritmo de la ruta más corta.
· Inundación (Flooding).
· Enrutamiento por vector de salida.
· Enrutamiento por estado del enlace.
· Enrutamiento en redes ad hoc.
· Enrutamiento por difusión.
· Enrutamiento multidifusión.
· Enrutamiento anycast.
· Enrutamiento para hosts móviles.
· Enrutamiento en redes ad hoc (de nuevo).

<p class="blue grande">Equilibrio vs Eficiencia</p>
Una vez que una red principal entra en operación, es de esperar que funcione
de manera continua durante años, sin fallas a nivel de sistema. Durante ese 
período habrá fallas de hardware y de software de todo tipo. Los hosts, 
enrutadores y líneas fallarán en forma repetida y la topología cambiará muchas
veces. El algoritmo de enrutamiento debe ser capaz de manejar los cambios de 
topología y tráfico sin necesidad de abortar todas las tareas en todos los hosts!!!
La estabilidad también es una meta importante para el algoritmo de enrutamiento.
Existen algoritmos de enrutamiento que nunca convergen hacia un conjunto de rutas
fijo, sin importar el tiempo que permanezcan en operación. Debe converger con rapidez
ya que se PUEDE INTERRUMPIR LA COMUNICACIÓN HASTA QUE EL ALGORITMO DE ENRUTAMIENTO HAYA
LLEGADO A UN EQUILIBRIO.
La equidad y la eficiencia parecen obvias, pero son metas contradictorias.


<img style="width:800px" src="eficiencia.png"/>

Hay suficiente tráfico entre A y A', entre B y B' y entre C y C' para saturar los enlaces
horizontales. Con el fin de maximizar el flujo total, es necesario suspender X a X' por
completo. Pero X y X' no lo ven de esa forma. Sin duda se requiere cierto compromiso entre
la ___eficiencia global___ y la equidad hacia las conexiones individuales.
En este ejemplo claro está que minimizar el retardo promedio de los paquetes es un cantidato
obvio para enviar tráfico a través de la red en forma __efectiva__, pero también lo es aumentar
al máximo la velocidad real de __transferencia total__ de la red. Estas dos metas están
en conflicto!! Muchas redes como término medio intentan minimizar la distancia que debe
recorrer el paquete, o simplemente reducir el número de saltos que tiene que dar un paquete.

<p class="blue grande">ALGORITMOS ADOPTATIVOS(enrutamiento dinámico) Y NO ADOPTATIVOS (enrutamiento estático)</p>
Uno cambia sus decisiones de enrutamiento para reflejar los cambios de la topología y algunas
veces también los cambios en el tráfico. Estos algoritmos de enrutamiento dinámico cambian
en cuanto al lugar de donde sacan su información por ejemplo cuando una topología cambia 
saca la info de otro lado, o cuando pasan X segundos o cuando hay mucho tráfico en alguna ruta.

<p class="blue grande">PRINCIPIO DE OPTIMIZACIÓN</p>
<img style="width:750px;" src="optimizacion.jpg"/>
Este principio establece que si el enrutador J está en la ruta óptima del enrutador I 
al enrutador K, entonces la ruta óptima de J a K también está en la misma ruta. Por
ejemplo llamemos r_1 a la parte de la ruta de I a J y r_2 al resto de la ruta. Si
existirera una ruta mejor que r_2 entre J y K, se podría concatenar con r_1 para mejorar
la ruta de I a K, lo cual contradice nuestro postulado de que r_1r_2 es óptima.
Dicho árbol se conoce como <p class="red">árbol sumidero(o árbol divergente)</p> y se ilusta en
la <p class="green">figura 5-6(b)</p>, donde la métrica de distancia es el número de saltos. El
objetivo de todos los algoritmos de enrutamiento es descubrir y usar los árboles sumidero 
para todos los enrutadores. Un árbol sumidero no es único, se denomina 
<b>DAG</b> en el caso de que se elijan todas las posibles rutas, DAG no tienen
ciclos. Puesto que un árbol sumidero es un árbol, no contiene ciclos, 
por lo que cada paquete se entregará en un número de saltos finito y limitado. 

<p class="blue grande">Algoritmo de la ruta más corta</p>
<img src="caminocorto.jpg"/>
Los primeros cinco pasos utilizados para calcular el camino más corto desde A hasta D. 
Las flechas indican el nodo de trabajo.

<p class="blue grande">Inundación</p>
Técnica en la que cada paquete entrante se envía en todas las líneas de salida, excepto
en la línea por la que llegó. La inundación genera grandes cantidades de paquetes
duplicados; de hecho, puede ser una cantidad infinita. Una de las medidas para 
controlar esta inundación es integrar un <p class="green">contador de saltos</p> 
y que el paquete se descarte cuando llegue a 0. Esta técnica puede producir un número
exponencial de paquetes duplicados a medida que aumenta el conteo de saltos y los
enrutadores duplican los paquetes que ya han visto antes. Una <p class="red">mejor
técnica</p> es llevar un registro de los paquetes difundidos en la inundación, 
para evitar enviarlos una segunda vez para lograr este objetivo hacemos que el 
enrutador de origen ponga un número de secuencia en cada paquete que reciba de sus hosts. 
Si un paquete de entrada está en la lista, no se difunde mediante inundación.
La técnica de inundación no es práctica pero asegura entregar los paquetes a todos 
los nodos de la red.

<p class="blue grande">Enrutamiento por vector de distancia</p>
<img src="vectordedistancia.jpg"/>
Opera haciendo que cada enrutador mantenga una tabla (un vector) que proporcione
la mejor distancia conocida a cada destino y el enlace que se puede usar para
llegar ahí. Para actualizar estas tablas se intercambia información con los
vecinos. Eventualmente, todos los ruteadores conocen el mejor enlace para alcanzar
cada destino.
En el enrutamiento por vector de distancia, cada enrutador mantiene una tabla de
enrutamiento indicada por cada enrutador de la red. Esta entrada consta de dos
partes: la línea preferida de salida a usar para ese destino y una estimación del
tiempo o distancia a ese destino. La distancia se podría medir como la cantidad
de saltos o se podría usar otra métrica.
Este proceso de actualización se ilusta en la <p class="green">figura 5-2</p>. En
la parte (a) se muestra una red. Las primeras cuatro columnas de la parte (b) 
muestran los <p class="green">vectores de retardo recibidos de los vecinos del 
enrutador</p> J. 

<p class="red grande">Limitaciones</p>
Un problema es el de la transmisión de malas noticias por la red tales como la 
ruptura de un enlace o la desaparición de un nodo. Este algoritmo converge 
lentamente en estos casos. Aunque el principal inconveniente de este algirtmo es
el de la cuenta a infinito.
<img src="conteoinfinito.JPG"/>
· Inicialmente A está desactivado. Cuando A se activa, B se entera de que A 
existe al recibir su vector distancia y actualizar su tabla indicando que A dista 1.

· El nodo C se entera de que A existe porque B le indica que tiene un enlace hacia
A de coste 1. Entonces C actualiza su tabla registrando una trayectoria hacia A 
de coste 2.

· Si el nodo A se desconecta entonces B no recibe el VD de A. Sin embargo el nodo 
C le dice que tiene una trayectoria hasta A de distancia 2. B no sabe que la 
trayectoria de C a A pasa por el mismo y por tanto cree que puede llegar a A 
a través de C por lo que actualiza su tabla registrando la distancia 
2 + 1 = 3 hasta A.

· En el siguiente intercambio, el nodo C comprueba que sus vecinos B y D tienen
una trayectoria hasta A de distancia 3. C calcula su propia distancia hasta 
A en 3 + 1 = 4. En los siguientes intercambios, los nodos elevan ilimitadamente
su distancia a A (cuenta a infinito).

Mientras no se interrumpa la cuenta a infinito, el algoritmo no converge. Aunque
se han propuesto diversas soluciones a este problema 

<p class="blue grande">Enrutamiento por estado de enlace</p>
<p class="green">Otra referencia:</p> <a href="http://giret.ufps.edu.co/cisco/descargas/Presentaciones/Modulo2_capitulo10.pdf">Enrutamiento por estado de enlace - Cisco</a>

El enrutamiento por vector de distancia se reemplazó por el enrutamiento por estado
del enlace. El principal problema que provocó su desaparición era que, con frecuencia
el algoritmo tardaba mucho en converger una vez que cambiana la topología de la red
<p class="red">(debido al problema del conteo al infinito)</p>.

<p class="red grande">Funcionamiento</p>
Lo podemos dividir en cinco pasos fundamentales:

· Descubrir a sus vecinos y sus direcciones.
· Medir el costo a cada uno de sus vecinos.
· Construir el paquete con la información recabada.
· Enviar este paquete al resto de routers
· Calcular la ruta mínima al resto de routers.

<div class="cita">
<b>Determinar los vecinos de cada nodo.</b> Para ello, manda un
paquete especial dependiendo que protocolo se utiliza, si es OSPF utilizará
<p class="red">HELLO</p> por cada línea punto a punto. Todo router que reciba
este paquete debe responder indicando su identidad.

<b>Cálculo del coste a los vecinos.</b> Cada router manda un
paquete especial <p class="red">ECHO</p> a través de la línea el cual debe 
volver a su origen. El tiempo de ida y vuelta dividido entre dos nodos da una
aproximación razonable del costo a cada vecino de la red.

<b>Elaboración de paquete de estado de enlace.</b> Consiste en que cada router
construye un paquete con todos los datos que informan del estado de la red. La
estructura de este paquete es la siguiente:

· Identidad del router
· Secuencia
· Edad
· Lista de nodos vecinos

El problema de esta etapa es el momento de la creación de estos paquetes. Hay
varias alternativas como hacerlo de manera periódica o bien cuando haya ocurrido
un evento en la red como la caída de un nodo.

<b>Distribución de paquete de estado de enlace.</b> Es la más complicada. Lo que
hace es repartir el paquete por toda la red por <p class="red">inundación</p>.
Para controlarla, cada paquete incluye un número de secuencia que aumenta con
cada paquete nuevo enviado (como vimos anteriormente en Inundación). Cada router
contiene una tabla con toda la información de tal manera que:
A pesar de todo, surgen ciertos problemas como el reinicio de la secuencia. Si
ocurre esto, se producirá un caos en la red. Solución usar secuencias de 32 bits,
lo suficientemente grandes para no tener que poner la secuencia a 0. Otros 
conflictos surgen en el caso de caída de un router (reinicio del número de 
secuencia) o si se recibe un número de secuencia equivocado por haberse modificado
alguno de sus bits durante la transmisión.
La solución introducir edad de cada paquete e ir disminuyéndola en un intervalo
pequeño de tiempo. Cuando llegue a 0, descartarlo. 

<b>Cálculo de ruta mínima.</b> Una vez que el router ha completado la recompilación
de información, puede construir el grafo de la subred. De esta manera, se puede
utilizar <a href="#">algoritmo de Dijkstra</a> para calcular el camino más corto
a todos los nodos.
</div>

<p class="blue grande">Encaminamiento jerárquico</p>
Problema: Las tablas que están en crecimiento constante no sólo consumen memoria
del enrutador, sino que también se necesita más tiempo de CPU para examinarlas y
más ancho de banda para enviar informes de estado entre enrutadores, la red 
puede crecer hasta el punto en que ya no sea viable que cada
enrutador tenga una entrada para cada uno de los demás enrutadores. Ahí es donde
entra el <p class="green">enrutamiento jerárquico</p>, como ocurre en la red telefónica.
Cuando se utiliza el enrutamiento jerárquico, los enrutadores se dividen en lo
que llamaremos <b>regiones</b>. Cada enrutador conoce todos los detalles para enrutar
paquetes a destinos dentro de su propia región, pero no sabe nada de la estructura
interna de las otras regiones. 

Un buen ejemplo sería considerar una empresa. La mayoría de las intranets
corporativas consisten en una red troncal de alta velocidad. Conectado a esta red
troncal hay enrutadores que a su vez están conectados a un grupo de trabajo en
particular. Estos grupos de trabajo ocupan una LAN única. <font color="red">La razón
por la cual este es un buen arreglo es porque aunque haya decenas de grupos de
trabajo diferentes, el lapso (recuento de saltos máximo para obtener de un host 
a cualquier otro host en la red) es 2</font>. Incluso si los grupos de trabajo
dividieron su red LAN en particiones más pequeñas, el lapso solo podría aumentar 
a 4 en este ejemplo particular.
<p class="green">Si cada enrutador estaba conectado a 2 enrutadores, muestra la conveniencia del
enrutamiento jerárquico. Disminuye la complejidad de la topología de red, aumenta
la eficiencia de enrutamiento y causa menos congestión</p>.

<p class="blue grande">Enrutamiento difusión</p>
El envío simultáneo de un paquete a todos los destinos se llama difusión
(broadcasting). Existen varios métodos para llevarla a cabo.
Un método de difusión que no requiere características especiales de la red es
que el origen sólo envíe un paquete distinto a cada destino. El método no sólo
desperdicia ancho de banda y es lento, sino que también requiere que el origen
tenga una lista completa de todos los destinos.
Una mejora es el <b>enrutamiento multidestino</b> es como los paquetes con
direccionamiento individual, sólo que cuand varios paquetes deben seguir la
misma ruta, uno de ellos paga la tarifa completa y los demás viajan gratis, el
ancho de banda se utiliza con más eficiencia. 
Ya hemos visto una mejor de enrutamiento por difusión: <p class="red">inundación</p>.
Cuando se implementa con un número de secuencia por cada origen, la 
inundación usa los enlaces de manera eficiente con una regla de decisión de los
enrutadores que es relativamente simple. La inundación es poco adecuada para la
comunicación punto a punto ordinaria, para difusión puede merecer que se le
considere con seriedad. Pero podemos hacer algo todavía mejor.

La idea del <b>reenvío por ruta invertida</b> es que cuando llega un paquete
difundido a un enrutador, éste lo revisa para ver si llegó por el enlace que se
usa por lo común para enviar paquetes hacia el origen de la difusión. De ser así
hay excelentes posibilidades de que el paquete difundido haya seguido la mejor
ruta desde el enrutador y por lo tanto sea la primera copia en llegar al enrutador.
Si éste es el caso, el enrutador reenvía copias del paquete a todos los enlaces,
excepto a aquel por el que llegó. No obstante, si el paquete difundido llegó por
un enlace diferente del preferido para llegar al origen, el paquete se descarta
como probable duplicado.

<p class="green">Ver figura 5-15 y página 328 de la 5ta edición de Andrew Tanenbaum</p>
...
(COMPLETAR)

<p class="blue grande">Enrutamiento multidifusión</p>
<p class="blue grande">Enrutamiento anycast</p>
<p class="blue grande">Enrutamiento para hosts móviles</p>
<p class="blue grande">Enrutamiento en redes ad hoc</p>

<p class="blue grande">Algoritmos de control de congestión</p>
































































































</pre>


</div>


</body>





</html>

